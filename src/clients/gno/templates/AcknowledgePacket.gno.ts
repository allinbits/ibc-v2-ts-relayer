export const Acknowledgement = `package main

import (
  "encoding/hex"

  "gno.land/p/aib/ibc/types"
  "gno.land/p/aib/ics23"
  "gno.land/r/aib/ibc/core"
)

func hexDec(s string) []byte {
  if s == "" {
    return nil
  }
  b, err := hex.DecodeString(s)
                 if err != nil { panic(err) }
  return b
}
func main() {
  // Acknowledge the packet
  specs := ics23.IavlSpec()
  ackPacket := types.MsgAcknowledgement{
    Packet: types.Packet{
      Sequence:          {{ sequence }},                        // XXX update
      SourceClient:      "{{ sourceClient }}",                // XXX update
      DestinationClient: "{{ destinationClient }}",          // XXX update
      TimeoutTimestamp:  uint64({{timestamp}}), // XXX update: must be the same as the timestamp of the send packet
      Payloads: []types.Payload{
      {{#each payloads}}
      {
        SourcePort:      "{{ this.sourcePort }}",             // XXX update
        DestinationPort: "{{ this.destinationPort }}", //XXX update
        Encoding:        "{{ this.encoding }}",
        Value:           hexDec("{{ this.value }}"),           // XXX update: the packet data
        Version:         "{{ this.version }}",         // XXX update: version of app (transfer uses v1)
      },
      {{/each}}
      },
    },
    Acknowledgement: types.Acknowledgement{
      // XXX update: this is the response of the app sent in the RecvPacket
      // response of the counterparty client.
      AppAcknowledgements: [][]byte{hexDec("{{ appAcknowledgement }}")},
    },
    // Write the proof of acknowledgement written during the RecvPacket of the
    // counterparty client.
    // NOTE proof generated by ./cmd/gen-proof MERKLE_PREFIX CLIENT_ID commitment APP_ACK
    ProofAcked: {{{ commitmentProof }}},
    ProofHeight: types.NewHeight({{ proofRevision }}, {{ proofHeight }}), // XXX update
  }

  res := core.Acknowledgement(cross, ackPacket)

  println(res)
}
`;
